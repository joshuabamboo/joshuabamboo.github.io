<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Flatiron | My Octopress Blog]]></title>
  <link href="http://joshuabamboo.github.io/blog/categories/flatiron/atom.xml" rel="self"/>
  <link href="http://joshuabamboo.github.io/"/>
  <updated>2014-10-29T00:37:35-04:00</updated>
  <id>http://joshuabamboo.github.io/</id>
  <author>
    <name><![CDATA[Josh Owens]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TIL Konstantin Haase Rebuilt Sinatra... In 6 Lines!]]></title>
    <link href="http://joshuabamboo.github.io/blog/2014/10/27/til-konstantin-haase-rebuilt-sinatra-dot-dot-dot-in-6-lines/"/>
    <updated>2014-10-27T20:44:47-04:00</updated>
    <id>http://joshuabamboo.github.io/blog/2014/10/27/til-konstantin-haase-rebuilt-sinatra-dot-dot-dot-in-6-lines</id>
    <content type="html"><![CDATA[<p>That&rsquo;s right - 6 Lines.</p>

<p>Sinatra, a stripped-down alternative to Ruby frameworks like Rails, is known for being lightweight and flexible. It&rsquo;s not a framework and doesn&rsquo;t require using the Model-View-Controller architecture pattern. Even still, a simple DSL like Sinatra has a lot going on behind the scenes. Sinatra is just under 2,000 lines of code (LOC). Rails, by comparison, is ??,???.</p>

<p>Konstantin Haase managed to create a Sinatra clone called <a href="https://github.com/rkh/almost-sinatra">Almost Sinatra</a> using just 6 lines of code. Here&rsquo;s it is:</p>

<pre><code class="ruby">    %w.rack tilt date INT TERM..map{|l|trap(l){$r.stop}rescue require l};$u=Date;$z=($u.new.year + 145).abs;puts "== Almost Sinatra/No Version has taken the stage on #$z for development with backup from Webrick"
    $n=Module.new{extend Rack;a,D,S,q=Rack::Builder.new,Object.method(:define_method),/@@ *([^\n]+)\n(((?!@@)[^\n]*\n)*)/m
    %w[get post put delete].map{|m|D.(m){|u,&amp;b|a.map(u){run-&gt;(e){[200,{"Content-Type"=&gt;"text/html"},[a.instance_eval(&amp;b)]]}}}}
    Tilt.mappings.map{|k,v|D.(k){|n,*o|$t||=(h=$u._jisx0301("hash, please");File.read(caller[0][/^[^:]+/]).scan(S){|a,b|h[a]=b};h);v[0].new(*o){n=="#{n}"?n:$t[n.to_s]}.render(a,o[0].try(:[],:locals)||{})}}
    %w[set enable disable configure helpers use register].map{|m|D.(m){|*_,&amp;b|b.try :[]}};END{Rack::Handler.get("webrick").run(a,Port:$z){|s|$r=s}}
    %w[params session].map{|m|D.(m){q.send m}};a.use Rack::Session::Cookie;a.use Rack::Lock;D.(:before){|&amp;b|a.use Rack::Config,&amp;b};before{|e|q=Rack::Request.new e;q.params.dup.map{|k,v|params[k.to_sym]=v}}}
</code></pre>

<p><img src="https://p.gr-assets.com/540x540/fit/hostedimages/1383924783/6705751.gif" alt="Mind Blown" /></p>

<p>This is obviously just a fun exercize. As he explains in <a href="http://vimeo.com/61087285">this video</a>, this was just &ldquo;an interesting project I did on the weekend.&rdquo; <a href="http://oi39.tinypic.com/14b6nmu.jpg">#NoBigDeal</a></p>

<p>Give the video a look and check him out of twitter <a href="https://twitter.com/konstantinhaase">@konstantinhaase</a>. Not only is the content interesting, he&rsquo;s a really funny guy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Communicating With Other Classes]]></title>
    <link href="http://joshuabamboo.github.io/blog/2014/10/14/communicating-with-other-classes/"/>
    <updated>2014-10-14T22:15:57-04:00</updated>
    <id>http://joshuabamboo.github.io/blog/2014/10/14/communicating-with-other-classes</id>
    <content type="html"><![CDATA[<p>When creating multiple classes, I noticed I was having a hard time wrapping my head around calling methods that weren&rsquo;t defined in my class. If you&rsquo;re like me, you had a hard time understanding how you could access methods from other classes. Here&rsquo;s an example of what I mean:</p>

<pre><code class="ruby">        class Artist
            @@artists = []
            attr_accessor :name, :songs, :genres

            def initialize
                @songs = []
            @genres = []
            @@artists &lt;&lt; self
            end

            def add_song(song)      ### passing in a parameter that's an instance of the Song class
                @songs &lt;&lt; song
            @genres &lt;&lt; song.genre    ### calling genre method from the Song class
            if song.genre                  
              song.genre.add_artist(self)
            end
            end
        end


        class Song
            attr_accessor :name, :artist, :genre

            def genre=(genre)       ### passing in a parameter that's an instance of the Genre class
                @genre = genre
                genre.add_song(self)  ### calling add_song method from the Genre class
            end
        end


        class Genre
                attr_accessor :name, :songs, :artists
                @@genres = []

            def initialize
                    @songs = [] 
                    @artists = []
                    @@genres &lt;&lt; self
            end


            def add_song(song)
                    @songs &lt;&lt; song
            end


            def add_artist(artist)
                    @artists &lt;&lt; artist
                    @artists.uniq!
            end
        end
</code></pre>

<p>Here we have three classes (Artist, Song, Genre). Notice the comments (###). These classes are calling methods that do not exist in their class. This can be confusing, especially if you&rsquo;re thinking about the concept of <a href="http://www.techotopia.com/index.php/Ruby_Variable_Scope">scope</a>. The method isn&rsquo;t defined. How could I possibly use it, right?! Wrong.</p>

<p>A simple step back helped me finally wrap my head around it. Think about a class that already exists that we use all the time, like arrays.</p>

<h5>Array is a class (Just like the ones we created above)</h5>

<pre><code class="ruby">        class Array
            ...
        end
</code></pre>

<h5>A new array is an instance within the class Array</h5>

<p><code>rappers = []</code></p>

<p>is the same as</p>

<p><code>rappers = Array.new</code></p>

<h5>Now we can pass our rappers array as an argument into another class&#8217; method</h5>

<pre><code class="ruby">        class Artist
            def count_rappers(rappers)
                rappers.size      ### calling size method on rappers array
            end             
        end
</code></pre>

<p>Note that we are calling size on rappers, but we have not defined any method called size in our Artist class. The reason we have access to the size method is because it is <a href="http://www.ruby-doc.org/core-2.1.3/Array.html">one of the many methods within the class Array</a>.</p>

<pre><code class="ruby ">        class Array
            def size
                ...
            end
        end
</code></pre>

<p>Rappers is an instance of the class Array; therefore, methods within that class can be called on the rappers array. This is really no different than the first example of the Artist, Genre and Song classes. Within the Artist class, the add_song method is being passed a parameter that is an instance of the Song class. This allows us to then call methods from the Song class on that instance. Similarly, in the Song class we can access the Genre class method by passing in an instance of Genre. As long as the method&rsquo;s parameter is an instance of a particular class, we will always be able to reach into that class.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post on Octopress]]></title>
    <link href="http://joshuabamboo.github.io/blog/2014/10/14/my-first-post-on-octopress/"/>
    <updated>2014-10-14T20:09:45-04:00</updated>
    <id>http://joshuabamboo.github.io/blog/2014/10/14/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://www.gravity.com/wp-content/uploads/2010/10/635x282xhello-world.gif.pagespeed.ic.WhWgdjIQuE.png">http://www.gravity.com/wp-content/uploads/2010/10/635x282xhello-world.gif.pagespeed.ic.WhWgdjIQuE.png</a>&#8221;></p>
]]></content>
  </entry>
  
</feed>
